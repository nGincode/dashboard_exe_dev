function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function createPagination(params) {
  var first = params.first,
    after = params.after,
    last = params.last,
    before = params.before;
  if (first === undefined && last === undefined) {
    throw new Error('pagination requires either a `first` or `last` param');
  }
  var paginationSliceParams = getInternalSliceParams({
    first: first,
    after: after,
    last: last,
    before: before
  });
  var comparator = getComparator(params.sortDirection, paginationSliceParams.direction);
  var sortDirection = getSortDirection(params.sortDirection, paginationSliceParams.direction);
  var sortColumn = getColumn(params.sortColumn);
  var cursorColumn = getColumn(params.cursorColumn);
  var orderBy = {
    column: sortColumn,
    direction: sortDirection
  };
  var returnableLimit = paginationSliceParams.limit;
  var queryableLimit = paginationSliceParams.limit + 1;
  var where = function () {
    if (paginationSliceParams.cursor === undefined) {
      // this is a noop where-clause value that can
      // be passed to knex .where in same way as the
      // non-noop where-clause value and still work
      return {
        column: function column(q) {
          return q;
        },
        comparator: '>',
        value: 0
      };
    }
    var _params$deobfuscateCu = params.deobfuscateCursor,
      deobfuscateCursor = _params$deobfuscateCu === void 0 ? atob : _params$deobfuscateCu;
    var cursor = deobfuscateCursor(paginationSliceParams.cursor);
    var subquery = function subquery(q) {
      return q.from(params.from).select(sortColumn).where(cursorColumn, '=', cursor);
    };
    return {
      column: sortColumn,
      comparator: comparator,
      value: subquery
    };
  }();
  var predicate = {
    orderBy: orderBy,
    limit: queryableLimit,
    where: where
  };
  var processItems = function processItems(rows) {
    if (rows.length === 0) {
      return [[], undefined];
    }
    if (rows.length <= returnableLimit) {
      return [paginationSliceParams.direction === 'backward' ? [].concat(rows.reverse()) : rows, undefined];
    }
    if (rows.length === queryableLimit) {
      var itemsOfPage = [].concat(rows);
      var adjacentItem = itemsOfPage.pop();
      return [paginationSliceParams.direction === 'backward' ? itemsOfPage.reverse() : itemsOfPage, adjacentItem];
    }
    throw new Error('the queried row count exceeds the expected limit based on the pagination params');
  };
  function getPage(rows, opts) {
    if (opts === void 0) {
      opts = {};
    }
    var _params$obfuscateCurs = params.obfuscateCursor,
      obfuscateCursor = _params$obfuscateCurs === void 0 ? btoa : _params$obfuscateCurs,
      _params$onCursorMissi = params.onCursorMissing,
      onCursorMissing = _params$onCursorMissi === void 0 ? 'omit' : _params$onCursorMissi;
    var _opts = opts,
      _opts$mapItem = _opts.mapItem,
      mapItem = _opts$mapItem === void 0 ? function (item) {
        return item;
      } : _opts$mapItem;
    var cursorAlias = getAlias(params.cursorColumn);
    var _processItems = processItems(rows),
      items = _processItems[0],
      adjacentItem = _processItems[1];
    if (items.length === 0) {
      return {
        edges: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
          endCursor: undefined,
          startCursor: undefined
        }
      };
    }
    var edges = [];
    for (var _iterator = _createForOfIteratorHelperLoose(items), _step; !(_step = _iterator()).done;) {
      var item = _step.value;
      var cursor = item[cursorAlias];
      if (cursor === undefined || cursor === null) {
        if (onCursorMissing === 'throw') {
          throw new Error('cursor is missing');
        } else {
          continue;
        }
      }
      var edge = {
        cursor: obfuscateCursor(cursor.toString()),
        node: mapItem(item)
      };
      edges.push(edge);
    }
    var pageInfo = {
      hasNextPage: paginationSliceParams.direction === 'backward' ? !!before : !!adjacentItem,
      hasPreviousPage: paginationSliceParams.direction === 'forward' ? !!after : !!adjacentItem,
      startCursor: edges[0].cursor,
      endCursor: edges[edges.length - 1].cursor
    };
    return {
      edges: edges,
      pageInfo: pageInfo
    };
  }
  return _extends({}, predicate, {
    getPage: getPage
  });
}
function getColumn(column) {
  if (typeof column === 'string') {
    return column;
  }
  var aliasedColumn = column;
  return aliasedColumn.column;
}
function getAlias(column) {
  if (typeof column === 'string') {
    return column;
  }
  var aliasedColumn = column;
  return aliasedColumn.alias;
}
function getInternalSliceParams(sliceParams) {
  if (sliceParams.last) {
    return {
      direction: 'backward',
      cursor: sliceParams.before,
      limit: sliceParams.last
    };
  }
  var forwardSliceParams = sliceParams;
  return {
    direction: 'forward',
    cursor: forwardSliceParams.after,
    limit: forwardSliceParams.first
  };
}
function getSortDirection(specifiedSortDirection, paginationDirection) {
  if (paginationDirection === 'forward') {
    return specifiedSortDirection;
  }
  if (specifiedSortDirection === 'desc') {
    return 'asc';
  }
  return 'desc';
}
function getComparator(specifiedSortDirection, paginationDirection) {
  if (specifiedSortDirection === 'desc') {
    if (paginationDirection === 'forward') {
      return '<';
    }
    if (paginationDirection === 'backward') {
      return '>';
    }
  }
  if (paginationDirection === 'forward') {
    return '>';
  }
  return '<';
}

export { createPagination };
//# sourceMappingURL=knex-relay-cursor-pagination.esm.js.map
