{"version":3,"file":"knex-relay-cursor-pagination.cjs.production.min.js","sources":["../src/knex-relay-cursor-pagination.ts"],"sourcesContent":["import { Knex } from 'knex';\n\ntype Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\ntype XOR<T, U> = T | U extends object\n  ? (Without<T, U> & U) | (Without<U, T> & T)\n  : T | U;\n\nexport type PaginationParams = PaginationSliceParams &\n  PaginationDatasetParams &\n  PaginationCursorParams;\n\nexport interface PaginationDatasetParams {\n  from: string;\n  cursorColumn: Column;\n  sortColumn: Column;\n  sortDirection: SortDirection;\n}\n\nexport interface PaginationCursorParams {\n  obfuscateCursor?: (cursor: Cursor) => Cursor;\n  deobfuscateCursor?: (obfuscatedCursor: Cursor) => Cursor;\n  onCursorMissing?: 'throw' | 'omit';\n}\n\ntype Column = XOR<string, AliasedColumn>;\n\ninterface AliasedColumn {\n  column: string;\n  alias: string;\n}\n\nexport type PaginationSliceParams = ForwardPaginationSliceParams &\n  BackwardPaginationSliceParams;\n\nexport interface ForwardPaginationSliceParams {\n  first?: number;\n  after?: Cursor;\n}\n\nexport interface BackwardPaginationSliceParams {\n  last?: number;\n  before?: Cursor;\n}\n\ninterface InternalSliceParams {\n  direction: PaginationDirection;\n  limit: number;\n  cursor?: Cursor;\n}\n\ntype PaginationDirection = 'forward' | 'backward';\n\nexport interface Predicate {\n  orderBy: OrderBy;\n  limit: number;\n  where: Where;\n}\n\nexport type Cursor = string | number;\n\nexport type OrderBy = {\n  column: string;\n  direction: SortDirection;\n};\n\nexport type SortDirection = 'asc' | 'desc';\n\nexport interface Where {\n  column: string;\n  comparator: Comparator;\n  value: (b: Knex.QueryBuilder) => Knex.QueryBuilder;\n}\n\nexport interface NoopWhere {\n  column: (q: Knex.QueryBuilder) => Knex.QueryBuilder;\n  comparator: '>';\n  value: 0;\n}\n\nexport interface Edge<T = unknown> {\n  cursor: Cursor;\n  node: T;\n}\n\nexport interface PageInfo {\n  endCursor?: Cursor;\n  hasNextPage: boolean;\n  hasPreviousPage: boolean;\n  startCursor?: Cursor;\n}\n\nexport interface Page<T = unknown> {\n  edges: Edge<T>[];\n  pageInfo: PageInfo;\n}\n\ntype Row = { [key: string]: unknown };\n\nexport function createPagination(params: PaginationParams) {\n  const { first, after, last, before } = params;\n\n  if (first === undefined && last === undefined) {\n    throw new Error('pagination requires either a `first` or `last` param');\n  }\n\n  const paginationSliceParams = getInternalSliceParams({\n    first,\n    after,\n    last,\n    before,\n  } as PaginationSliceParams);\n\n  const comparator = getComparator(\n    params.sortDirection,\n    paginationSliceParams.direction\n  );\n  const sortDirection = getSortDirection(\n    params.sortDirection,\n    paginationSliceParams.direction\n  );\n  const sortColumn = getColumn(params.sortColumn);\n  const cursorColumn = getColumn(params.cursorColumn);\n\n  const orderBy: OrderBy = {\n    column: sortColumn,\n    direction: sortDirection,\n  };\n  const returnableLimit = paginationSliceParams.limit;\n  const queryableLimit = paginationSliceParams.limit + 1;\n\n  const where = ((): Where => {\n    if (paginationSliceParams.cursor === undefined) {\n      // this is a noop where-clause value that can\n      // be passed to knex .where in same way as the\n      // non-noop where-clause value and still work\n      return {\n        column: (q: Knex.QueryBuilder) => q,\n        comparator: '>',\n        value: 0,\n      } as unknown as Where;\n    }\n\n    const { deobfuscateCursor = atob } = params;\n    const cursor = deobfuscateCursor(paginationSliceParams.cursor as string);\n\n    const subquery = (q: Knex.QueryBuilder): any =>\n      q\n        .from(params.from)\n        .select(sortColumn)\n        .where(cursorColumn, '=', cursor as Knex.Value);\n\n    return {\n      column: sortColumn,\n      comparator: comparator,\n      value: subquery,\n    };\n  })();\n\n  const predicate: Predicate = {\n    orderBy,\n    limit: queryableLimit,\n    where,\n  };\n\n  const processItems = (rows: Row[]): [Row[], Row | undefined] => {\n    if (rows.length === 0) {\n      return [[], undefined];\n    }\n\n    if (rows.length <= returnableLimit) {\n      return [\n        paginationSliceParams.direction === 'backward'\n          ? [...rows.reverse()]\n          : rows,\n        undefined,\n      ];\n    }\n\n    if (rows.length === queryableLimit) {\n      const itemsOfPage = [...rows];\n      const adjacentItem = itemsOfPage.pop();\n      return [\n        paginationSliceParams.direction === 'backward'\n          ? itemsOfPage.reverse()\n          : itemsOfPage,\n        adjacentItem,\n      ];\n    }\n\n    throw new Error(\n      'the queried row count exceeds the expected limit based on the pagination params'\n    );\n  };\n\n  function getPage<T = Row>(\n    rows: Row[],\n    opts: { mapItem?: (item: Row) => T } = {}\n  ): Page<T> {\n    const { obfuscateCursor = btoa, onCursorMissing = 'omit' } = params;\n    const { mapItem = (item: Row) => item } = opts;\n    const cursorAlias = getAlias(params.cursorColumn);\n\n    const [items, adjacentItem] = processItems(rows);\n\n    if (items.length === 0) {\n      return {\n        edges: [],\n        pageInfo: {\n          hasNextPage: false,\n          hasPreviousPage: false,\n          endCursor: undefined,\n          startCursor: undefined,\n        },\n      };\n    }\n\n    const edges = [];\n    for (const item of items) {\n      const cursor = item[cursorAlias];\n      if (cursor === undefined || cursor === null) {\n        if (onCursorMissing === 'throw') {\n          throw new Error('cursor is missing');\n        } else {\n          continue;\n        }\n      }\n\n      const edge = {\n        cursor: obfuscateCursor(cursor.toString()),\n        node: mapItem(item as Row),\n      };\n\n      edges.push(edge);\n    }\n\n    const pageInfo: PageInfo = {\n      hasNextPage:\n        paginationSliceParams.direction === 'backward'\n          ? !!before\n          : !!adjacentItem,\n      hasPreviousPage:\n        paginationSliceParams.direction === 'forward'\n          ? !!after\n          : !!adjacentItem,\n      startCursor: edges[0].cursor,\n      endCursor: edges[edges.length - 1].cursor,\n    };\n\n    return {\n      edges,\n      pageInfo,\n    } as unknown as Page<T>;\n  }\n\n  return {\n    ...predicate,\n    getPage,\n  };\n}\n\nfunction getColumn(column: Column): string {\n  if (typeof column === 'string') {\n    return column;\n  }\n  const aliasedColumn = column as AliasedColumn;\n  return aliasedColumn.column;\n}\n\nfunction getAlias(column: Column): string {\n  if (typeof column === 'string') {\n    return column;\n  }\n  const aliasedColumn = column as AliasedColumn;\n  return aliasedColumn.alias;\n}\n\nfunction getInternalSliceParams(\n  sliceParams: PaginationSliceParams\n): InternalSliceParams {\n  if (sliceParams.last) {\n    return {\n      direction: 'backward',\n      cursor: sliceParams.before,\n      limit: sliceParams.last,\n    };\n  }\n\n  const forwardSliceParams = sliceParams as ForwardPaginationSliceParams;\n  return {\n    direction: 'forward',\n    cursor: forwardSliceParams.after,\n    limit: forwardSliceParams.first,\n  } as InternalSliceParams;\n}\n\nfunction getSortDirection(\n  specifiedSortDirection: SortDirection,\n  paginationDirection: PaginationDirection\n) {\n  if (paginationDirection === 'forward') {\n    return specifiedSortDirection;\n  }\n\n  if (specifiedSortDirection === 'desc') {\n    return 'asc';\n  }\n\n  return 'desc';\n}\n\ntype Comparator = '<' | '>';\n\nfunction getComparator(\n  specifiedSortDirection: SortDirection,\n  paginationDirection: PaginationDirection\n): Comparator {\n  if (specifiedSortDirection === 'desc') {\n    if (paginationDirection === 'forward') {\n      return '<';\n    }\n    if (paginationDirection === 'backward') {\n      return '>';\n    }\n  }\n\n  if (paginationDirection === 'forward') {\n    return '>';\n  }\n\n  return '<';\n}\n"],"names":["getColumn","column","params","first","after","last","before","undefined","Error","specifiedSortDirection","sliceParams","paginationSliceParams","direction","cursor","limit","comparator","paginationDirection","getComparator","sortDirection","sortColumn","cursorColumn","orderBy","returnableLimit","queryableLimit","where","q","value","_params$deobfuscateCu","deobfuscateCursor","atob","from","select","_extends","getPage","rows","opts","_params$obfuscateCurs","obfuscateCursor","btoa","_params$onCursorMissi","onCursorMissing","_opts$mapItem","mapItem","item","cursorAlias","alias","_processItems","length","concat","reverse","itemsOfPage","adjacentItem","pop","processItems","items","edges","pageInfo","hasNextPage","hasPreviousPage","endCursor","startCursor","_step","_iterator","_createForOfIteratorHelperLoose","done","edge","toString","node","push"],"mappings":"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"}